{"mappings":"AASE,MAAAA,EAIAC,QAAA,K,QAOO,K,sBAIA,6BAkBPC,YAAAC,EAAA,MAAAC,EAAAC,KAAAD,WAEAC,KAAAF,QAAAG,SAAAC,gBAAAH,EAAAD,GAQEE,MAAKG,EAAQL,GACbE,KAAKI,YAAQN,EAEI,QAAjBE,KAAOI,aAAUJ,KAAAF,QAAAO,aAAA,QAAAN,EACnB,C,MAoBIO,G,SAEAC,YAAYP,KAAAF,SACZE,I,QAQkCF,GAKpC,OAHAE,KAAIQ,MAAS,IAAAb,EAAgBG,GAC7BE,KAAIF,QAAOS,YAAWP,KAAOQ,MAAMV,SAE9BE,KAAQQ,K,cAiBPC,EAAOC,EAAkB,KAAKC,GAAA,EAAAC,EAAA,OAAAC,EAAA,Q,IAElCC,EAAA,IAAAnB,EAAiB,Q,KAAC,C,IAAMoB,EAAAN,EAAA,GAAMO,EAAAP,EAAA,GAAMQ,EAAAR,IAAAS,OAAA,GAAMC,EAAAV,IAAAS,OAAA,G,EAAIE,KAAAL,EAAAC,G,EAAKK,QAAAJ,EAAAE,EACrD,CAEAV,EAASA,EAAAa,O,IAGPC,EAAM,MAFHZ,EAAAF,EAAA,GAAAA,EAAA,GACKE,EAAAF,EAAA,GAAAA,EAAA,MAOZe,EAAAb,EAAA,IAEAc,EAAAd,EAAAF,EAAAS,OAAA,EAAAT,EAAAS,OAAA,EAWE,IAAI,IAAEQ,EAAAF,EAASE,EAAAD,EAAAC,GAAA,GAEf,IAAMC,EAAAD,EAAWjB,EAAIiB,EAAA,GAAAjB,EAAA,GACrBmB,EAAaF,EAAAjB,EAAAiB,EAAA,GAAAjB,EAAA,GACPoB,EAAApB,EAAAiB,GACJI,EAAArB,EAAiBiB,EAAE,GACnBK,EAAAtB,EAAAiB,EAAoB,GACtBM,EAAAvB,EAAAiB,EAAA,GAkBAH,GAAgB,KAAI,CAbbM,GAAAE,EAAAJ,GAAA,EAAAjB,EACToB,GAAAE,EAAAJ,GAAA,EAAAlB,EAEAqB,IANeL,IAAMjB,EAAAS,OAAS,EAAAT,EAAAiB,EAAA,GAAAK,GAM9BF,GAAA,EAAAnB,EAQiBsB,IAbVN,IAAYjB,EAASS,OAAO,EAAAT,EAAAiB,EAAA,GAAAM,GAalBF,GAAA,EAAApB,EAMVqB,EAEEC,IAGT,CAyBE,OArBAlB,EAAKmB,IAAA,CACPC,EAAAX,EAEAX,SAOEC,KAAOA,IAGTb,KAAAF,QAAAS,YAAAO,EAAAhB,SAQOgB,C,gBAuBIqB,EAAGC,EAAM,SAAOC,EAAA,GAAAC,EAAA,qB,MACvBC,I,MACAC,EAAQ,IAAM7C,EAA4C,GAAAyC,a,EACrDH,IAAA,CACLE,GAAIA,EACNM,cAAA,GAAAH,IAEII,kBAAS,UAAiBL,OAKhC,OAHErC,MAAA2C,IAEApC,YAAWiC,EAAA1C,SACb0C,CAEA,C,cA4BQL,GAENnC,MAAIuC,IAGN,MAAAK,EAAA,IAAAjD,EAAA,WACFiD,EAAAX,IAAA,C,s/BC7PIY,EAAoC,C,UA2B7B,SAAUC,EAAAC,EAAOC,GAC1B,OAAAC,KAAAF,IAAAE,KAAAD,IAAAF,EAAAC,GAAAC,EAEA,E","sources":["src/sv.js","src/gen.js"],"sourcesContent":["/**\r\n * A class to instantiate a new SvJs element.\r\n */\r\nclass SvJs {\r\n\r\n  /**\r\n   * Class fields.\r\n   */\r\n  cursorX = null;\r\n  cursorY = null;\r\n  elementName;\r\n  namespace = 'http://www.w3.org/2000/svg';\r\n\r\n  /**\r\n   * Create an SVG element.\r\n   * \r\n   * @param {string} element - The name of the SVG element to create. \r\n   * @param {string} namespace - The namespace url to reference.\r\n   */\r\n  constructor(element = 'svg', namespace = this.namespace) {\r\n    this.element = document.createElementNS(namespace, element);\r\n\r\n    this.#isValid(element);\r\n\r\n    this.elementName = element;\r\n\r\n    if (this.elementName === 'svg') {\r\n      this.element.setAttribute('xmlns', namespace);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add the SVG element to the specified node.\r\n   * \r\n   * @chainable\r\n   * @param {node} node - A HTML or SVG parent node.\r\n   * @returns {object} itself.\r\n   */\r\n  addTo(node) {\r\n    node.appendChild(this.element);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Create and append an SVG child element.\r\n   *\r\n   * @chainable\r\n   * @param {string} element - The name of the SVG element to create.\r\n   * @returns {object} The created SVG child element.\r\n   */\r\n  create(element) {\r\n    this.child = new SvJs(element);\r\n    this.element.appendChild(this.child.element);\r\n\r\n    return this.child;\r\n  }\r\n\r\n  /**\r\n   * Creates a smooth bezier curve from an array of points.\r\n   * \r\n   * @chainable\r\n   * @param {array} points - A two-dimensional array of [[x,y], [x,y]...] points.\r\n   * @param {number} curveFactor - 0 means no curve. Default is 1.66 (approximates a circle given a square).\r\n   * @param {boolean} isClosed - Is the curve open or closed. Default is false (an open curve).\r\n   * @param {string} stroke - The stroke colour. Black by default.\r\n   * @param {string} fill - The fill colour. None by default.\r\n   * @returns {object} The created path.\r\n   */\r\n  createBezier(points, curveFactor = 1.66, isClosed = false, stroke = '#000', fill = 'none') {\r\n    let path = new SvJs('path');\r\n\r\n    if (isClosed) {\r\n      let first = points[0];\r\n      let second = points[1];\r\n      let secondLast = points[points.length - 2];\r\n      let last = points[points.length - 1];\r\n  \r\n      points.push(first, second);\r\n      points.unshift(secondLast, last);\r\n    }\r\n  \r\n    points = points.flat();\r\n  \r\n    let moveX = isClosed ? points[2] : points[0];\r\n    let moveY = isClosed ? points[3] : points[1];\r\n  \r\n    let pathData = `M ${[moveX, moveY]}`;\r\n  \r\n    let iStart = isClosed ? 2 : 0;\r\n    let iEnd = isClosed ? points.length - 4 : points.length - 2;\r\n  \r\n    for (let i = iStart; i < iEnd; i += 2) {\r\n      let x0 = i ? points[i - 2] : points[0];\r\n      let y0 = i ? points[i - 1] : points[1];\r\n  \r\n      let x1 = points[i];\r\n      let y1 = points[i + 1];\r\n  \r\n      let x2 = points[i + 2];\r\n      let y2 = points[i + 3];\r\n  \r\n      let x3 = i !== points.length - 4 ? points[i + 4] : x2;\r\n      let y3 = i !== points.length - 4 ? points[i + 5] : y2;\r\n  \r\n      let cp1x = x1 + ((x2 - x0) / 6) * curveFactor;\r\n      let cp1y = y1 + ((y2 - y0) / 6) * curveFactor;\r\n  \r\n      let cp2x = x2 - ((x3 - x1) / 6) * curveFactor;\r\n      let cp2y = y2 - ((y3 - y1) / 6) * curveFactor;\r\n  \r\n      pathData += `C ${[cp1x, cp1y, cp2x, cp2y, x2, y2]}`;\r\n    }\r\n\r\n    path.set({\r\n      d: pathData,\r\n      stroke: stroke,\r\n      fill: fill\r\n    });\r\n\r\n    this.element.appendChild(path.element);\r\n\r\n    return path;\r\n  }\r\n\r\n  /**\r\n   * Create a gradient and append it to the defs element.\r\n   * \r\n   * @chainable\r\n   * @param {string} id - The id. Reference this when applying the gradient.\r\n   * @param {string} type - Accepts linear or radial.\r\n   * @param {number} rotation - The angle of rotation. \r\n   * @param {string} units - Accepts userSpaceOnUse or objectBoundingBox.\r\n   * @returns {object} The created gradient element.\r\n   */\r\n  createGradient(id, type = 'linear', rotation = 45, units = 'objectBoundingBox') {\r\n    this.#isMainSVG();\r\n    \r\n    const gradient = new SvJs(`${type}Gradient`);\r\n    gradient.set({\r\n      id: id,\r\n      gradientUnits : `${units}`,\r\n      gradientTransform: `rotate(${rotation})`\r\n    });\r\n\r\n    const defs = this.#defsCheck();\r\n    defs.appendChild(gradient.element);\r\n\r\n    return gradient;\r\n  }\r\n\r\n  /**\r\n   * Create a pattern and append it to the defs element.\r\n   * \r\n   * @chainable\r\n   * @param {string} id - The id. Reference this when applying the gradient.\r\n   * @returns {object} The created pattern element.\r\n   */\r\n  createPattern(id) {\r\n    this.#isMainSVG();\r\n    \r\n    const pattern = new SvJs('pattern');\r\n    pattern.set({ id: id });\r\n\r\n    const defs = this.#defsCheck();\r\n    defs.appendChild(pattern.element);\r\n\r\n    return pattern;\r\n  }\r\n\r\n  /**\r\n   * Delete the SVG element.\r\n   */\r\n  delete() {\r\n    this.element.remove();\r\n  }\r\n\r\n  /**\r\n   * Get a given attribute's value.\r\n   * \r\n   * @param {*} attribute - The attribute.\r\n   * @returns {*} the attribute value.\r\n   */\r\n  get(attribute) {\r\n    return this.element.getAttributeNS(null, attribute);\r\n  }\r\n\r\n  /**\r\n   * Set the attribute values of an SVG element. Replaces _ with - for relevant attributes.\r\n   * \r\n   * @chainable\r\n   * @param {object} attributes - An object of attribute value pairs.\r\n   * @returns {object} itself.\r\n   */\r\n  set(attributes) {\r\n    for (let key in attributes) {\r\n      let prop = key.replace(/_/g, '-');\r\n      \r\n      this.element.setAttributeNS(null, prop, attributes[key]);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Update the cursorX and cursorY properties on the main SVG element.\r\n   * Accurate cursor tracking via matrix transformation. Compatible with touch devices.\r\n   * \r\n   * @chainable\r\n   * @returns {object} itself.\r\n   */\r\n  trackCursor() {\r\n    this.#isMainSVG();\r\n\r\n    let point = this.element.createSVGPoint();\r\n\r\n    this.element.addEventListener('pointermove', (event) => {\r\n      this.element.style.touchAction = 'none';\r\n      point.x = event.clientX;\r\n      point.y = event.clientY;\r\n      point = point.matrixTransform(this.element.getScreenCTM().inverse());\r\n      this.cursorX = Math.ceil(point.x);\r\n      this.cursorY = Math.ceil(point.y);\r\n    });\r\n\r\n    this.element.addEventListener('pointerleave', () => {\r\n      this.element.style.touchAction = 'auto';\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Check if the def element already exists, and create it if it doesn't.\r\n   * \r\n   * @returns {object} The defs element.\r\n   */\r\n  #defsCheck(element) {\r\n    return document.querySelector('defs') ?\r\n      document.querySelector('defs')\r\n      : this.create('defs').element;\r\n  }\r\n\r\n  /**\r\n   * Check if the element is the main SVG element.\r\n   * \r\n   * @throws {error} if the element is not the main SVG.\r\n   */\r\n  #isMainSVG() {\r\n    if (this.elementName !== 'svg') {\r\n      throw new Error('This function can only be called on the main SVG element.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if the created SVG element is valid.\r\n   * \r\n   * @param {string} element - The SVG element name to validate.\r\n   */\r\n  #isValid(element) {\r\n    const elementToString = Object.prototype.toString.call(this.element).toLowerCase();\r\n\r\n    if (elementToString !== `[object svg${element.toLowerCase()}element]`) {\r\n      throw new Error(`Invalid SVG element: ${elementToString}`); \r\n    }\r\n  }\r\n}\r\n\r\nexport { SvJs };\r\n","/**\r\n * A collection of useful functions for generative art.\r\n */\r\nconst gen = {\r\n  /**\r\n   * Constrains (or clamps) a value between a minimum and maximum value.\r\n   * \r\n   * @param {number} num - The number to constrain.\r\n   * @param {number} min - The minimum limit.\r\n   * @param {number} max - The maximum limit.\r\n   * @returns {number} The constrained number.\r\n   */\r\n  constrain: function(num, min, max) {\r\n    return Math.min(Math.max(num, min), max);\r\n  },\r\n\r\n  /**\r\n   * Calculates the distance between two points using the Pythagorean theorem.\r\n   * \r\n   * @param {number} x1 - The first x co-ordinate.\r\n   * @param {number} y1 - The first y co-ordinate.\r\n   * @param {number} x2 - The second x co-ordinate.\r\n   * @param {number} y2 - The second y co-ordinate.\r\n   * @returns {number} The distance between (x1, y1) and (x2, y2).\r\n   */\r\n  dist: function(x1, y1, x2, y2) {\r\n    let a = x1 - x2;\r\n    let b = y1 - y2;\r\n    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\r\n  },\r\n\r\n  /**\r\n   * Interpolates linearly between two values. Returns the midway point (0.5) by default.\r\n   * \r\n   * @param {number} start - The first value.\r\n   * @param {number} stop - The second value.\r\n   * @param {number} amount - The amount of interpolation, between 0.0 and 1.0.\r\n   * @returns {number} The interpolated value.\r\n   */\r\n  interp: function(start, stop, amount = 0.5) {\r\n    return amount * (stop - start) + start;\r\n  },\r\n\r\n  /**\r\n   * Re-maps a number from one range to another.\r\n   *\r\n   * @param {number} value - The value to be converted.\r\n   * @param {number} start1 - The lower bound of the current range.\r\n   * @param {number} stop1 - The upper bound of the current range.\r\n   * @param {number} start2 - The lower bound of the target range.\r\n   * @param {number} stop2 - The upper bound of the target range.\r\n   * @returns {number} The remapped number.\r\n   */\r\n  mapRange: function(value, start1, stop1, start2, stop2) {\r\n    return (value - start1) / (stop1 - start1) * (stop2 - start2) + start2;\r\n  },\r\n\r\n  /**\r\n   * Gets a random number between a minimum and maximum value.\r\n   * \r\n   * @param {number} min - Result is equal to or higher than this.\r\n   * @param {number} max - Result is lower than this.\r\n   * @param {boolean} integer - Default is false. Set to true to return an integer.\r\n   * @returns {number} The random number.\r\n   */\r\n  random: function(min = 0, max = 1, integer = false) {\r\n    let random = Math.random() * (max - min) + min;\r\n    return integer ? Math.floor(random) : random;\r\n  }\r\n}\r\n\r\nexport { gen };\r\n"],"names":["$85e5d838be2bb839$export$6db80416c61d51ca","cursorX","constructor","element","namespace","this","document","createElementNS","isValid","elementName","setAttribute","node","appendChild","child","points","curveFactor","isClosed","stroke","fill","path","first","second","secondLast","length","last","push","unshift","flat","pathData","iStart","iEnd","i","x0","y0","x1","y1","x2","y2","set","d","id","type","rotation","units","isMainSVG","gradient","gradientUnits","gradientTransform","defsCheck","pattern","$097705c8ce77c34c$export$ca954a7249f984a5","num","min","max","Math"],"version":3,"file":"svjs.min.js.map"}