{"mappings":"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","sources":["src/sv.js","src/gen.js","src/noise.js"],"sourcesContent":["/**\r\n * A class to instantiate a new SvJs element.\r\n */\r\nclass SvJs {\r\n\r\n  /**\r\n   * Class fields.\r\n   */\r\n  cursorX = null;\r\n  cursorY = null;\r\n  elementName;\r\n  namespace = 'http://www.w3.org/2000/svg';\r\n\r\n  /**\r\n   * Create an SVG element.\r\n   * \r\n   * @param {string} [element] - The name of the SVG element to create. \r\n   * @param {string} [namespace] - The namespace url to reference.\r\n   */\r\n  constructor(element = 'svg', namespace = this.namespace) {\r\n    this.element = document.createElementNS(namespace, element);\r\n\r\n    this.#isValid(element);\r\n\r\n    this.elementName = element;\r\n\r\n    if (this.elementName === 'svg') {\r\n      this.element.setAttribute('xmlns', namespace);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add the SVG element to the specified node.\r\n   * \r\n   * @chainable\r\n   * @param {node} node - A HTML or SVG parent node.\r\n   * @returns {object} itself.\r\n   */\r\n  addTo(node) {\r\n    node.appendChild(this.element);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Inserts content within an element. Useful for textual elements.\r\n   * \r\n   * @chainable\r\n   * @param {string} text - The content to insert.\r\n   * @returns {object} itself.\r\n   */\r\n  content(text) {\r\n    this.element.innerHTML = text;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Create and append an SVG child element.\r\n   *\r\n   * @chainable\r\n   * @param {string} element - The name of the SVG element to create.\r\n   * @returns {object} The created SVG child element.\r\n   */\r\n  create(element) {\r\n    this.child = new SvJs(element);\r\n    this.element.appendChild(this.child.element);\r\n\r\n    return this.child;\r\n  }\r\n\r\n  /**\r\n   * Creates a smooth bezier curve from an array of points.\r\n   * \r\n   * @chainable\r\n   * @param {array} points - A two-dimensional array of [[x,y], [x,y]...] points.\r\n   * @param {number} [curveFactor] - 0 means no curve. Default is 1.66 (approximates a circle given a square).\r\n   * @param {boolean} [isClosed] - Is the curve open or closed. Default is false (an open curve).\r\n   * @param {string} [stroke] - The stroke colour. Black by default.\r\n   * @param {string} [fill] - The fill colour. None by default.\r\n   * @returns {object} The created path.\r\n   */\r\n  createCurve(points, curveFactor = 1.66, isClosed = false, stroke = '#000', fill = 'none') {\r\n    let path = new SvJs('path');\r\n\r\n    if (isClosed) {\r\n      let first = points[0];\r\n      let second = points[1];\r\n      let secondLast = points[points.length - 2];\r\n      let last = points[points.length - 1];\r\n  \r\n      points.push(first, second);\r\n      points.unshift(secondLast, last);\r\n    }\r\n  \r\n    points = points.flat();\r\n  \r\n    let moveX = isClosed ? points[2] : points[0];\r\n    let moveY = isClosed ? points[3] : points[1];\r\n  \r\n    let pathData = `M ${[moveX, moveY]}`;\r\n  \r\n    let iStart = isClosed ? 2 : 0;\r\n    let iEnd = isClosed ? points.length - 4 : points.length - 2;\r\n  \r\n    for (let i = iStart; i < iEnd; i += 2) {\r\n      let x0 = i ? points[i - 2] : points[0];\r\n      let y0 = i ? points[i - 1] : points[1];\r\n  \r\n      let x1 = points[i];\r\n      let y1 = points[i + 1];\r\n  \r\n      let x2 = points[i + 2];\r\n      let y2 = points[i + 3];\r\n  \r\n      let x3 = i !== points.length - 4 ? points[i + 4] : x2;\r\n      let y3 = i !== points.length - 4 ? points[i + 5] : y2;\r\n  \r\n      let cp1x = x1 + ((x2 - x0) / 6) * curveFactor;\r\n      let cp1y = y1 + ((y2 - y0) / 6) * curveFactor;\r\n  \r\n      let cp2x = x2 - ((x3 - x1) / 6) * curveFactor;\r\n      let cp2y = y2 - ((y3 - y1) / 6) * curveFactor;\r\n  \r\n      pathData += `C ${[cp1x, cp1y, cp2x, cp2y, x2, y2]}`;\r\n    }\r\n\r\n    path.set({\r\n      d: pathData,\r\n      stroke: stroke,\r\n      fill: fill\r\n    });\r\n\r\n    this.element.appendChild(path.element);\r\n\r\n    return path;\r\n  }\r\n\r\n  /**\r\n   * Create a gradient and append it to the defs element.\r\n   * \r\n   * @chainable\r\n   * @param {string} id - The id. Reference this when applying the gradient.\r\n   * @param {string} type - Accepts linear or radial.\r\n   * @param {array} colours - An array of gradient colours to be applied equidistantly.\r\n   * @param {number} [rotation = 45] - The angle of rotation. Ignored if gradient is radial.\r\n   * @returns {object} The created gradient element.\r\n   */\r\n  createGradient(id, type, colours, rotation = 45) {\r\n    this.#isMainSVG();\r\n    \r\n    let gradient = new SvJs(`${type}Gradient`);\r\n    gradient.set({ id: id });\r\n\r\n    if (type === 'linear') {\r\n      gradient.set({ gradientTransform: `rotate(${rotation})` });\r\n    }\r\n\r\n    for (let i = 0; i < colours.length; i += 1) {\r\n      gradient.create('stop').set({\r\n        stop_color: colours[i],\r\n        offset: i * (100 / (colours.length - 1)) / 100\r\n      });\r\n    }\r\n\r\n    let defs = this.#defsCheck();\r\n    defs.appendChild(gradient.element);\r\n\r\n    return gradient;\r\n  }\r\n\r\n  /**\r\n   * Create a pattern and append it to the defs element.\r\n   * \r\n   * @chainable\r\n   * @param {string} id - The id. Reference this when applying the gradient.\r\n   * @param {number} width - The width of the pattern.\r\n   * @param {number} height - The height of the pattern.\r\n   * @returns {object} The created pattern element.\r\n   */\r\n  createPattern(id, width, height) {\r\n    this.#isMainSVG();\r\n    \r\n    let pattern = new SvJs('pattern');\r\n    pattern.set({\r\n      id: id,\r\n      x: 0,\r\n      y: 0,\r\n      width: width,\r\n      height: height,\r\n      patternUnits: 'userSpaceOnUse'\r\n    });\r\n\r\n    let defs = this.#defsCheck();\r\n    defs.appendChild(pattern.element);\r\n\r\n    return pattern;\r\n  }\r\n\r\n  /**\r\n   * Delete the SVG element.\r\n   */\r\n  delete() {\r\n    this.element.remove();\r\n  }\r\n\r\n  /**\r\n   * Get a given attribute's value.\r\n   * \r\n   * @param {string} attribute - The attribute.\r\n   * @returns {*} the attribute value.\r\n   */\r\n  get(attribute) {\r\n    return this.element.getAttributeNS(null, attribute);\r\n  }\r\n\r\n  /**\r\n   * Get a given element's centre { x, y } co-ordinates.\r\n   * \r\n   * @returns {object} the centre.x and centre.y co-ordinates.\r\n   */\r\n  getCentre() {\r\n    let bbox = this.element.getBBox();\r\n    let cx = bbox.x + (bbox.width / 2);\r\n    let cy = bbox.y + (bbox.height / 2);\r\n    return { x: cx, y: cy };\r\n  }\r\n\r\n  /**\r\n   * Move an element to a desired position with respect to its centre.\r\n   * \r\n   * @chainable\r\n   * @param {number} x - The target x co-ordinate.\r\n   * @param {number} y - The target y co-ordinate.\r\n   * @returns {object} itself.\r\n   */\r\n  moveTo(x, y) {\r\n    let c = this.getCentre();\r\n    let t = this.#createTransform();\r\n    \r\n    t.setTranslate(x - c.x, y - c.y);\r\n\r\n    this.#addTransform(t);\r\n    \r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Rotate an element around a specified origin point (the element centre by default).\r\n   * \r\n   * @chainable\r\n   * @param {number} angle - The angle of rotation.\r\n   * @param {number} [cx] - The origin x co-ordinate.\r\n   * @param {number} [cy] - The origin y co-ordinate.\r\n   * @returns {object} itself.\r\n   */\r\n  rotate(angle, cx = null, cy = null) {\r\n    let c = this.getCentre();\r\n    let t = this.#createTransform();\r\n    cx = (cx === null) ? c.x : cx;\r\n    cy = (cy === null) ? c.y : cy;\r\n\r\n    t.setRotate(angle, cx, cy);\r\n\r\n    this.#addTransform(t);\r\n    \r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Saves and downloads the SVG markup.\r\n   */\r\n  save() {\r\n    let data = this.element.outerHTML;\r\n    let file = new Blob([data], { type: 'text/plain;charset=utf-8' });\r\n    let a = document.createElement('a');\r\n    a.href = URL.createObjectURL(file);\r\n    a.download = prompt('Enter the file name', 'download.svg');\r\n    a.click();\r\n  }\r\n\r\n  /**\r\n   * Scale an element by a desired proportion.\r\n   * \r\n   * @chainable\r\n   * @param {number} sx - The amount to scale on the x-axis.\r\n   * @param {number} [sy] - The amount to scale on the y-axis. Defaults to sx if not supplied.\r\n   * @returns {object} itself.\r\n   */\r\n  scale(sx, sy = null) {\r\n    let c = this.getCentre();\r\n    let t1 = this.#createTransform();\r\n    let t2 = this.#createTransform();\r\n\r\n    sy = (sy === null) ? sx : sy;\r\n    t1.setTranslate((1 - sx) * c.x, (1 - sy) * c.y);\r\n    t2.setScale(sx, sy);\r\n    \r\n    this.#addTransform(t1);\r\n    this.#addTransform(t2);\r\n    \r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the attribute values of an SVG element. Replaces _ with - for relevant attributes.\r\n   * \r\n   * @chainable\r\n   * @param {object} attributes - An object of attribute value pairs.\r\n   * @returns {object} itself.\r\n   */\r\n  set(attributes) {\r\n    for (let key in attributes) {\r\n      let prop = key.replace(/_/g, '-');\r\n      \r\n      this.element.setAttributeNS(null, prop, attributes[key]);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Update the cursorX and cursorY properties on the main SVG element.\r\n   * Accurate cursor tracking via matrix transformation. Compatible with touch devices.\r\n   * \r\n   * @chainable\r\n   * @returns {object} itself.\r\n   */\r\n  trackCursor() {\r\n    this.#isMainSVG();\r\n\r\n    let point = this.element.createSVGPoint();\r\n\r\n    this.element.addEventListener('pointermove', (event) => {\r\n      this.element.style.touchAction = 'none';\r\n      point.x = event.clientX;\r\n      point.y = event.clientY;\r\n      point = point.matrixTransform(this.element.getScreenCTM().inverse());\r\n      this.cursorX = Math.ceil(point.x);\r\n      this.cursorY = Math.ceil(point.y);\r\n    });\r\n\r\n    this.element.addEventListener('pointerleave', () => {\r\n      this.element.style.touchAction = 'auto';\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Appends an SVG transform object to a transform list.\r\n   * \r\n   * @param {object} transform - An SVGTransform object.\r\n   */\r\n  #addTransform(transform) {\r\n    this.element.transform.baseVal.appendItem(transform);\r\n  }\r\n\r\n  /**\r\n   * Alows for the creation of a cumulative transform.\r\n   * \r\n   * @returns {object} An SVGTransform object.\r\n   */\r\n  #createTransform() {\r\n    let root = new SvJs();\r\n    return root.element.createSVGTransform();\r\n  }\r\n\r\n  /**\r\n   * Check if the def element already exists, and create it if it doesn't.\r\n   * \r\n   * @returns {object} The defs element.\r\n   */\r\n  #defsCheck(element) {\r\n    return document.querySelector('defs') ?\r\n      document.querySelector('defs')\r\n      : this.create('defs').element;\r\n  }\r\n\r\n  /**\r\n   * Check if the element is the main SVG element.\r\n   * \r\n   * @throws {error} if the element is not the main SVG.\r\n   */\r\n  #isMainSVG() {\r\n    if (this.elementName !== 'svg') {\r\n      throw new Error('This function can only be called on the main SVG element.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if the created SVG element is valid.\r\n   * \r\n   * @param {string} element - The SVG element name to validate.\r\n   */\r\n  #isValid(element) {\r\n    let elementToString = Object.prototype.toString.call(this.element).toLowerCase();\r\n\r\n    if (elementToString !== `[object svg${element.toLowerCase()}element]`) {\r\n      throw new Error(`Invalid SVG element: ${elementToString}`); \r\n    }\r\n  }\r\n}\r\n\r\nexport { SvJs };\r\n","/**\r\n * A collection of useful functions for generative art.\r\n */\r\nconst Gen = {\r\n  /**\r\n   * Return true if the supplied % is higher than a randomised %. If two arguments supplied, they are interpreted as odds.\r\n   * \r\n   * @param {number} [n1 = 50] - The chance of the return value being true. 50 by default.\r\n   * @param {number} [n2 = null] - If not null, both arguments are interpreted as odds in the form n1 to n2.\r\n   * @returns {boolean}\r\n   */\r\n  chance: function(n1 = 50, n2 = null) {\r\n    let n = (n2 !== null) ? n2 / (n1 + n2) * 100 : n1;\r\n    return n > (Math.random() * 100);\r\n  },\r\n\r\n  /**\r\n   * Constrains (or clamps) a value between a minimum and maximum value.\r\n   * \r\n   * @param {number} num - The number to constrain.\r\n   * @param {number} min - The minimum limit.\r\n   * @param {number} max - The maximum limit.\r\n   * @returns {number} The constrained number.\r\n   */\r\n  constrain: function(num, min, max) {\r\n    return Math.min(Math.max(num, min), max);\r\n  },\r\n\r\n  /**\r\n   * Calculates the distance between two points using the Pythagorean theorem.\r\n   * \r\n   * @param {number} x1 - The first x co-ordinate.\r\n   * @param {number} y1 - The first y co-ordinate.\r\n   * @param {number} x2 - The second x co-ordinate.\r\n   * @param {number} y2 - The second y co-ordinate.\r\n   * @returns {number} The distance between (x1, y1) and (x2, y2).\r\n   */\r\n  dist: function(x1, y1, x2, y2) {\r\n    let a = x1 - x2;\r\n    let b = y1 - y2;\r\n    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\r\n  },\r\n\r\n  /**\r\n   * Gets a random number based on the Box-Muller gaussian transform.\r\n   * By default, it typically returns results within a range of -3 to +3.\r\n   * \r\n   * @param {number} [mean = 0] - The mean, 0 by default.\r\n   * @param {number} [sigma = 1] - Sigma refers to the standard deviation, 1 by default.\r\n   * @param {boolean} [float = true] - Set to false to return an integer.\r\n   * @returns {number} The random gaussian.\r\n   */\r\n  gaussian: function(mean = 0, sigma = 1, float = true) {\r\n    let u = 1 - Math.random();\r\n    let v = Math.random();\r\n    let z = Math.cos(Math.PI * v) * Math.sqrt(-Math.log(u));\r\n    let g = z * sigma + mean;\r\n    return float ? g : Math.round(g);\r\n  },\r\n\r\n  /**\r\n   * Interpolates linearly between two values. Returns the midway point (0.5) by default.\r\n   * \r\n   * @param {number} start - The first value.\r\n   * @param {number} stop - The second value.\r\n   * @param {number} [amount = 0.5] - The amount of interpolation, between 0.0 and 1.0.\r\n   * @returns {number} The interpolated value.\r\n   */\r\n  interp: function(start, stop, amount = 0.5) {\r\n    return amount * (stop - start) + start;\r\n  },\r\n\r\n  /**\r\n   * Re-maps a number from one range to another.\r\n   *\r\n   * @param {number} value - The value to be converted.\r\n   * @param {number} start1 - The lower bound of the current range.\r\n   * @param {number} stop1 - The upper bound of the current range.\r\n   * @param {number} start2 - The lower bound of the target range.\r\n   * @param {number} stop2 - The upper bound of the target range.\r\n   * @param {boolean} [float = true] - Set to false to return an integer.\r\n   * @returns {number} The remapped number.\r\n   */\r\n  mapRange: function(value, start1, stop1, start2, stop2, float = true) {\r\n    let n = (value - start1) / (stop1 - start1) * (stop2 - start2) + start2;\r\n    return float ? n : Math.round(n);\r\n  },\r\n\r\n  /**\r\n   * Gets a random number based on the pareto power law distribution (80-20 rule).\r\n   *\r\n   * @param {number} min - The minimum value to be returned.\r\n   * @param {boolean} [float = true] - Set to false to return an integer.\r\n   * @returns {number} The random pareto number.\r\n   */\r\n  pareto: function(min, float = true) {\r\n    let n = 1.0 - Math.random();\r\n    let a = Math.log(5) / Math.log(4);\r\n    let p = min / Math.pow(n, 1.0 / a);\r\n    return float ? p : Math.round(p);\r\n  },\r\n\r\n  /**\r\n   * Gets a random number between a minimum and maximum value, or picks a random item from an array.\r\n   * \r\n   * @param {(number|array)} [min = 0] - Result is equal to or higher than this. If array, an item is randomly chosen.\r\n   * @param {number} [max = 1] - Result is equal to or lower than this.\r\n   * @param {boolean} [float = true] - Set to false to return an integer.\r\n   * @returns {*} The randomised number or array item.\r\n   */\r\n  random: function(min = 0, max = 1, float = true) {\r\n    if (Array.isArray(arguments[0])) {\r\n      let arr = arguments[0];\r\n      return arr[Math.round(Math.random() * (arr.length - 1))];\r\n    } else {\r\n      let random = Math.random() * (max - min) + min;\r\n      return float ? random : Math.round(random);\r\n    }\r\n  }\r\n}\r\n\r\nexport { Gen };\r\n","/**\r\n * An implementation of Ken Perlin's noise algorithm in 2D.\r\n * \r\n * With thanks to Joe Iddon. https://github.com/joeiddon/perlin\r\n */\r\nclass Noise {\r\n  constructor() {\r\n    this.grad = {};\r\n    this.cache = {};\r\n  }\r\n\r\n  /**\r\n   * Get the noise value at the specified co-ordinates.\r\n   * \r\n   * @param {number} x - The noise x co-ordinate.\r\n   * @param {number} [y = 0] - The noise y co-ordinate.\r\n   * @returns {number} the noise value (float between -1 and 1).\r\n   */\r\n  get(x, y = 0) {\r\n    if (this.cache.hasOwnProperty([x, y])) return this.cache[[x, y]];\r\n    \r\n    let xf = Math.floor(x);\r\n    let yf = Math.floor(y);\r\n    \r\n    let tl = this.#gridDotProduct(x, y, xf, yf);\r\n    let tr = this.#gridDotProduct(x, y, xf + 1, yf);\r\n    let bl = this.#gridDotProduct(x, y, xf, yf + 1);\r\n    let br = this.#gridDotProduct(x, y, xf + 1, yf + 1);\r\n    \r\n    let xt = this.#fade(x - xf, tl, tr);\r\n    let xb = this.#fade(x - xf, bl, br);\r\n    let v = this.#fade(y - yf, xt, xb);\r\n    \r\n    this.cache[[x, y]] = v;\r\n    \r\n    return v;\r\n  }\r\n\r\n  #gridDotProduct(x, y, vx, vy){\r\n    let gVec, dVec = { x: x - vx, y: y - vy };\r\n\r\n    if (this.grad[[vx, vy]]){\r\n      gVec = this.grad[[vx, vy]];\r\n    } else {\r\n      let th = Math.random() * 2 * Math.PI;\r\n      gVec = { x: Math.cos(th), y: Math.sin(th) };\r\n      this.grad[[vx, vy]] = gVec;\r\n    }\r\n\r\n    return dVec.x * gVec.x + dVec.y * gVec.y;\r\n  }\r\n\r\n  #fade(x, a, b){\r\n    let s = 6 * x**5 - 15 * x**4 + 10 * x**3;\r\n    return a + s * (b - a);\r\n  }\r\n}\r\n\r\nexport { Noise };\r\n"],"names":["$85e5d838be2bb839$export$6db80416c61d51ca","cursorX","constructor","element","namespace","this","document","createElementNS","isValid","elementName","setAttribute","node","appendChild","text","innerHTML","child","points","curveFactor","isClosed","stroke","fill","first","second","secondLast","length","last","push","unshift","flat","pathData","iStart","iEnd","i","x0","y0","x1","y1","x2","y2","path","set","d","createGradient","id","type","colours","rotation","isMainSVG","gradient","gradientTransform","create","stop_color","offset","defsCheck","width","height","pattern","x","y","patternUnits","remove","attribute","getAttributeNS","bbox","getBBox","moveTo","c","getCentre","t","createTransform","setTranslate","addTransform","$097705c8ce77c34c$export$dde7b1cd7af1d184","n1","n2","Math","random","constrain","num","min","max","a","b","sqrt","pow","$61af366e9716361c$export$484d33a0500a4ce1","grad","cache","hasOwnProperty","xf","floor","yf","tl","gridDotProduct","tr","bl","br","xt","fade","xb","v","vx","vy","gVec","dVec","th","PI","cos","sin"],"version":3,"file":"svjs.min.js.map"}