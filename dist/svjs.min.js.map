{"mappings":"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","sources":["src/sv.js","src/gen.js","src/noise.js"],"sourcesContent":["/**\r\n * A class to instantiate a new SvJs element.\r\n */\r\nclass SvJs {\r\n\r\n  /**\r\n   * Class fields.\r\n   */\r\n  cursorX = null;\r\n  cursorY = null;\r\n  namespace = 'http://www.w3.org/2000/svg';\r\n\r\n  /**\r\n   * Create an SVG element.\r\n   * \r\n   * @param {string} [element] - The name of the SVG element to create. \r\n   * @param {string} [namespace] - The namespace url to reference.\r\n   */\r\n  constructor(element = 'svg', namespace = this.namespace) {\r\n    this.element = document.createElementNS(namespace, element);\r\n\r\n    this.#isValid(element);\r\n\r\n    if (this.element.nodeName === 'svg') {\r\n      this.element.setAttribute('xmlns', namespace);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * An alias of the DOM addEventListener method.\r\n   * \r\n   * @chainable\r\n   * @param {Event} type - The event type.\r\n   * @param {function} callback - The callback function.\r\n   * @returns {object} itself.\r\n   */\r\n  addEventListener(type, callback) {\r\n    this.element.addEventListener(type, callback);\r\n    \r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add the SVG element to the specified node.\r\n   * \r\n   * @chainable\r\n   * @param {node} node - A HTML or SVG parent node.\r\n   * @returns {object} itself.\r\n   */\r\n  addTo(node) {\r\n    node.appendChild(this.element);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Animate an element using the Web Animations API.\r\n   * \r\n   * @chainable\r\n   * @param {(array|object)} keyframes - An array of keyframe objects, or an object of keyframe arrays.\r\n   * @param {object} options - A single duration, or an object containing timing properties. \r\n   * @returns {object} itself.\r\n   */\r\n  animate(keyframes, options) {\r\n    this.element.animate(keyframes, options);\r\n    \r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Inserts content within an element. Useful for textual elements.\r\n   * \r\n   * @chainable\r\n   * @param {string} text - The content to insert.\r\n   * @returns {object} itself.\r\n   */\r\n  content(text) {\r\n    this.element.innerHTML = text;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Create and append an SVG child element.\r\n   *\r\n   * @chainable\r\n   * @param {string} element - The name of the SVG element to create.\r\n   * @returns {object} The created SVG child element.\r\n   */\r\n  create(element) {\r\n    this.child = new SvJs(element);\r\n\r\n    if (element === 'defs') {\r\n      this.child.element = this.#defsCheck();\r\n    } else {\r\n      this.element.appendChild(this.child.element);\r\n    }\r\n\r\n    return this.child;\r\n  }\r\n\r\n  /**\r\n   * Creates a smooth, open bezier curve from an array of points.\r\n   * \r\n   * @chainable\r\n   * @param {array} points - A two-dimensional array of [[x,y], [x,y]...] points.\r\n   * @param {number} [curveFactor = 1] - 0 means that points connected by straight lines. Default is 1.\r\n   * @returns {object} The created path.\r\n   */\r\n  createCurve(points, curveFactor = 1) {\r\n    let path = new SvJs('path');\r\n  \r\n    points = points.flat();\r\n  \r\n    let pathData = `M ${[points[0], points[1]]}`;\r\n  \r\n    for (let i = 0; i < points.length - 2; i += 2) {\r\n      let x0 = i ? points[i - 2] : points[0];\r\n      let y0 = i ? points[i - 1] : points[1];\r\n  \r\n      let x1 = points[i];\r\n      let y1 = points[i + 1];\r\n  \r\n      let x2 = points[i + 2];\r\n      let y2 = points[i + 3];\r\n  \r\n      let x3 = i !== points.length - 4 ? points[i + 4] : x2;\r\n      let y3 = i !== points.length - 4 ? points[i + 5] : y2;\r\n  \r\n      let cp1x = x1 + ((x2 - x0) / 6) * curveFactor;\r\n      let cp1y = y1 + ((y2 - y0) / 6) * curveFactor;\r\n  \r\n      let cp2x = x2 - ((x3 - x1) / 6) * curveFactor;\r\n      let cp2y = y2 - ((y3 - y1) / 6) * curveFactor;\r\n  \r\n      pathData += `C ${[cp1x, cp1y, cp2x, cp2y, x2, y2]}`;\r\n    }\r\n\r\n    path.set({\r\n      d: pathData,\r\n      stroke: '#888',\r\n      fill: 'none'\r\n    });\r\n\r\n    this.element.appendChild(path.element);\r\n\r\n    return path;\r\n  }\r\n\r\n  /**\r\n   * Creates a filter and appends it to the defs element.\r\n   * \r\n   * @chainable\r\n   * @param {string} id - The id. Reference this when applying the filter.\r\n   * @returns {object} The created filter.\r\n   */\r\n  createFilter(id) {\r\n    this.#isMainSVG();\r\n\r\n    let filter = new SvJs('filter');\r\n    filter.set({\r\n      id: id,\r\n      x: '-25%',\r\n      y: '-25%',\r\n      width: '150%',\r\n      height: '150%',\r\n      filterUnits: 'userSpaceOnUse',\r\n      color_interpolation_filters: 'sRGB'\r\n    });\r\n\r\n    let defs = this.#defsCheck();\r\n    defs.appendChild(filter.element);\r\n\r\n    return filter;\r\n  }\r\n\r\n  /**\r\n   * Creates a gradient and appends it to the defs element.\r\n   * \r\n   * @chainable\r\n   * @param {string} id - The id. Reference this when applying the gradient.\r\n   * @param {string} type - Accepts linear or radial.\r\n   * @param {array} colours - An array of gradient colours to be applied equidistantly.\r\n   * @param {number} [rotation = 45] - The angle of rotation. Ignored if gradient is radial.\r\n   * @returns {object} The created gradient.\r\n   */\r\n  createGradient(id, type, colours, rotation = 45) {\r\n    this.#isMainSVG();\r\n    \r\n    let gradient = new SvJs(`${type}Gradient`);\r\n    gradient.set({ id: id });\r\n\r\n    if (type === 'linear') {\r\n      gradient.set({ gradientTransform: `rotate(${rotation})` });\r\n    }\r\n\r\n    for (let i = 0; i < colours.length; i += 1) {\r\n      gradient.create('stop').set({\r\n        stop_color: colours[i],\r\n        offset: i * (100 / (colours.length - 1)) / 100\r\n      });\r\n    }\r\n\r\n    let defs = this.#defsCheck();\r\n    defs.appendChild(gradient.element);\r\n\r\n    return gradient;\r\n  }\r\n\r\n  /**\r\n   * Creates a pattern and appends it to the defs element.\r\n   * \r\n   * @chainable\r\n   * @param {string} id - The id. Reference this when applying the gradient.\r\n   * @param {number} width - The width of the pattern.\r\n   * @param {number} height - The height of the pattern.\r\n   * @returns {object} The created pattern element.\r\n   */\r\n  createPattern(id, width, height) {\r\n    this.#isMainSVG();\r\n    \r\n    let pattern = new SvJs('pattern');\r\n    pattern.set({\r\n      id: id,\r\n      x: 0,\r\n      y: 0,\r\n      width: width,\r\n      height: height,\r\n      patternUnits: 'userSpaceOnUse'\r\n    });\r\n\r\n    let defs = this.#defsCheck();\r\n    defs.appendChild(pattern.element);\r\n\r\n    return pattern;\r\n  }\r\n\r\n  /**\r\n   * Delete the SVG element.\r\n   */\r\n  delete() {\r\n    this.element.remove();\r\n  }\r\n\r\n  /**\r\n   * Get a given attribute's value.\r\n   * \r\n   * @param {string} attribute - The attribute.\r\n   * @returns {*} the attribute value.\r\n   */\r\n  get(attribute) {\r\n    return this.element.getAttributeNS(null, attribute);\r\n  }\r\n\r\n  /**\r\n   * Get a given element's centre { x, y } co-ordinates.\r\n   * \r\n   * @returns {object} the centre.x and centre.y co-ordinates.\r\n   */\r\n  getCentre() {\r\n    let bbox = this.element.getBBox();\r\n    let cx = bbox.x + (bbox.width / 2);\r\n    let cy = bbox.y + (bbox.height / 2);\r\n    return { x: cx, y: cy };\r\n  }\r\n\r\n  /**\r\n   * Move an element to a desired position with respect to its centre.\r\n   * \r\n   * @chainable\r\n   * @param {number} x - The target x co-ordinate.\r\n   * @param {number} y - The target y co-ordinate.\r\n   * @returns {object} itself.\r\n   */\r\n  moveTo(x, y) {\r\n    let c = this.getCentre();\r\n    let t = this.#createTransform();\r\n    \r\n    t.setTranslate(x - c.x, y - c.y);\r\n\r\n    this.#addTransform(t);\r\n    \r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Rotate an element around a specified origin point (the element centre by default).\r\n   * \r\n   * @chainable\r\n   * @param {number} angle - The angle of rotation.\r\n   * @param {number} [cx] - The origin x co-ordinate.\r\n   * @param {number} [cy] - The origin y co-ordinate.\r\n   * @returns {object} itself.\r\n   */\r\n  rotate(angle, cx = null, cy = null) {\r\n    let c = this.getCentre();\r\n    let t = this.#createTransform();\r\n    cx = (cx === null) ? c.x : cx;\r\n    cy = (cy === null) ? c.y : cy;\r\n\r\n    t.setRotate(angle, cx, cy);\r\n\r\n    this.#addTransform(t);\r\n    \r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Saves and downloads the SVG markup.\r\n   */\r\n  save() {\r\n    let name = prompt('Enter the file name', 'sketch.svg');\r\n    if (name !== null) {\r\n      let a = document.createElement('a');\r\n      a.download = name;\r\n      let data = this.element.outerHTML;\r\n      let file = new Blob([data], { type: 'text/plain;charset=utf-8' });\r\n      a.href = URL.createObjectURL(file);\r\n      a.click();\r\n    } else {\r\n      return;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scale an element by a desired proportion.\r\n   * \r\n   * @chainable\r\n   * @param {number} sx - The amount to scale on the x-axis.\r\n   * @param {number} [sy] - The amount to scale on the y-axis. Defaults to sx if not supplied.\r\n   * @returns {object} itself.\r\n   */\r\n  scale(sx, sy = null) {\r\n    let c = this.getCentre();\r\n    let t1 = this.#createTransform();\r\n    let t2 = this.#createTransform();\r\n\r\n    sy = (sy === null) ? sx : sy;\r\n    t1.setTranslate((1 - sx) * c.x, (1 - sy) * c.y);\r\n    t2.setScale(sx, sy);\r\n    \r\n    this.#addTransform(t1);\r\n    this.#addTransform(t2);\r\n    \r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the attribute values of an SVG element. Replaces _ with - for relevant attributes.\r\n   * \r\n   * @chainable\r\n   * @param {object} attributes - An object of attribute value pairs.\r\n   * @returns {object} itself.\r\n   */\r\n  set(attributes) {\r\n    for (let key in attributes) {\r\n      let prop = key.replace(/_/g, '-');\r\n      \r\n      this.element.setAttributeNS(null, prop, attributes[key]);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Update the cursorX and cursorY properties on the main SVG element.\r\n   * Accurate cursor tracking via matrix transformation. Compatible with touch devices.\r\n   * \r\n   * @chainable\r\n   * @param {function} callback - An optional callback function to trigger whenever the cursor moves.\r\n   * @returns {object} itself.\r\n   */\r\n  trackCursor(callback = null) {\r\n    this.#isMainSVG();\r\n\r\n    let point = new DOMPoint();\r\n\r\n    this.element.addEventListener('pointermove', (event) => {\r\n      this.element.style.touchAction = 'none';\r\n      point.x = event.clientX;\r\n      point.y = event.clientY;\r\n      point = point.matrixTransform(this.element.getScreenCTM().inverse());\r\n      this.cursorX = Math.ceil(point.x);\r\n      this.cursorY = Math.ceil(point.y);\r\n    });\r\n\r\n    this.element.addEventListener('pointerleave', () => {\r\n      this.element.style.touchAction = 'auto';\r\n    });\r\n\r\n    if (callback !== null) {\r\n      this.element.addEventListener('pointermove', callback);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Appends an SVG transform object to a transform list.\r\n   * \r\n   * @param {object} transform - An SVGTransform object.\r\n   */\r\n  #addTransform(transform) {\r\n    this.element.transform.baseVal.appendItem(transform);\r\n  }\r\n\r\n  /**\r\n   * Alows for the creation of a cumulative transform.\r\n   * \r\n   * @returns {object} An SVGTransform object.\r\n   */\r\n  #createTransform() {\r\n    let root = new SvJs();\r\n    return root.element.createSVGTransform();\r\n  }\r\n\r\n  /**\r\n   * Checks if the def element already exists, and creates it if it doesn't.\r\n   * \r\n   * @returns {object} The defs element.\r\n   */\r\n  #defsCheck() {\r\n    let defs;\r\n    if (document.querySelector('defs')) {\r\n      defs = document.querySelector('defs');\r\n    } else {\r\n      defs = new SvJs('defs').element;\r\n      this.element.prepend(defs);\r\n    }\r\n    return defs;\r\n  }\r\n\r\n  /**\r\n   * Check if the element is the main SVG element.\r\n   * \r\n   * @throws {error} if the element is not the main SVG.\r\n   */\r\n  #isMainSVG() {\r\n    if (this.element.nodeName !== 'svg') {\r\n      throw new Error('This function can only be called on the main SVG element.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if the created SVG element is valid.\r\n   * \r\n   * @param {string} element - The SVG element name to validate.\r\n   */\r\n  #isValid(element) {\r\n    let elementToString = Object.prototype.toString.call(this.element).toLowerCase();\r\n\r\n    if (elementToString !== `[object svg${element.toLowerCase()}element]`) {\r\n      throw new Error(`Invalid SVG element: ${elementToString}`); \r\n    }\r\n  }\r\n}\r\n\r\nexport { SvJs };\r\n","/**\r\n * A collection of useful functions for generative art.\r\n */\r\nconst Gen = {\r\n  /**\r\n   * Return true if the supplied % is higher than a randomised %. If two arguments supplied, they are interpreted as odds.\r\n   * \r\n   * @param {number} [n1 = 50] - The chance of the return value being true. 50 by default.\r\n   * @param {number} [n2 = null] - If not null, both arguments are interpreted as odds in the form n1 to n2.\r\n   * @returns {boolean} true or false.\r\n   */\r\n  chance: function(n1 = 50, n2 = null) {\r\n    let n = (n2 !== null) ? n2 / (n1 + n2) * 100 : n1;\r\n    return n > (Math.random() * 100);\r\n  },\r\n\r\n  /**\r\n   * Constrains (or clamps) a value between a minimum and maximum value.\r\n   * \r\n   * @param {number} num - The number to constrain.\r\n   * @param {number} min - The minimum limit.\r\n   * @param {number} max - The maximum limit.\r\n   * @returns {number} The constrained number.\r\n   */\r\n  constrain: function(num, min, max) {\r\n    return Math.min(Math.max(num, min), max);\r\n  },\r\n\r\n  /**\r\n   * Calculates the distance between two points using the Pythagorean theorem.\r\n   * \r\n   * @param {number} x1 - The first x co-ordinate.\r\n   * @param {number} y1 - The first y co-ordinate.\r\n   * @param {number} x2 - The second x co-ordinate.\r\n   * @param {number} y2 - The second y co-ordinate.\r\n   * @returns {number} The distance between (x1, y1) and (x2, y2).\r\n   */\r\n  dist: function(x1, y1, x2, y2) {\r\n    let a = x1 - x2;\r\n    let b = y1 - y2;\r\n    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\r\n  },\r\n\r\n  /**\r\n   * Gets a random number based on the Box-Muller gaussian transform.\r\n   * \r\n   * By default, it typically returns results within a range of -3 to +3.\r\n   * \r\n   * @param {number} [mean = 0] - The mean, 0 by default.\r\n   * @param {number} [sigma = 1] - Sigma refers to the standard deviation, 1 by default.\r\n   * @param {boolean} [float = true] - Set to false to return an integer.\r\n   * @returns {number} The random gaussian.\r\n   */\r\n  gaussian: function(mean = 0, sigma = 1, float = true) {\r\n    let u = 1 - Math.random();\r\n    let v = Math.random();\r\n    let z = Math.cos(Math.PI * v) * Math.sqrt(-Math.log(u));\r\n    let g = z * sigma + mean;\r\n    return float ? g : Math.round(g);\r\n  },\r\n\r\n  /**\r\n   * Interpolates linearly between two values. Returns the midway point (0.5) by default.\r\n   * \r\n   * @param {number} start - The first value.\r\n   * @param {number} stop - The second value.\r\n   * @param {number} [amount = 0.5] - The amount of interpolation, between 0.0 and 1.0.\r\n   * @returns {number} The interpolated value.\r\n   */\r\n  interp: function(start, stop, amount = 0.5) {\r\n    return amount * (stop - start) + start;\r\n  },\r\n\r\n  /**\r\n   * Re-maps a number from one range to another.\r\n   *\r\n   * @param {number} value - The value to be converted.\r\n   * @param {number} start1 - The lower bound of the current range.\r\n   * @param {number} stop1 - The upper bound of the current range.\r\n   * @param {number} start2 - The lower bound of the target range.\r\n   * @param {number} stop2 - The upper bound of the target range.\r\n   * @param {boolean} [float = true] - Set to false to return an integer.\r\n   * @returns {number} The remapped number.\r\n   */\r\n  map: function(value, start1, stop1, start2, stop2, float = true) {\r\n    let n = (value - start1) / (stop1 - start1) * (stop2 - start2) + start2;\r\n    return float ? n : Math.round(n);\r\n  },\r\n\r\n  /**\r\n   * Gets a random number based on the pareto power law distribution (80-20 rule).\r\n   *\r\n   * @param {number} min - The minimum value to be returned.\r\n   * @param {boolean} [float = true] - Set to false to return an integer.\r\n   * @returns {number} The random pareto number.\r\n   */\r\n  pareto: function(min, float = true) {\r\n    let n = 1.0 - Math.random();\r\n    let a = Math.log(5) / Math.log(4);\r\n    let p = min / Math.pow(n, 1.0 / a);\r\n    return float ? p : Math.round(p);\r\n  },\r\n\r\n  /**\r\n   * Gets a random number between a minimum and maximum value, or picks a random item from an array.\r\n   * \r\n   * @param {(number|array)} [min = 0] - Result is equal to or higher than this. If array, an item is randomly chosen.\r\n   * @param {number} [max = 1] - Result is equal to or lower than this.\r\n   * @param {boolean} [float = false] - Set to true to return a floating point number.\r\n   * @returns {*} The randomised number or array item.\r\n   */\r\n  random: function(min = 0, max = 1, float = false) {\r\n    if (Array.isArray(arguments[0])) {\r\n      let arr = arguments[0];\r\n      return arr[Math.round(Math.random() * (arr.length - 1))];\r\n    } else {\r\n      let random = Math.random() * (max - min) + min;\r\n      return (float || max - min <= 1) ? random : Math.round(random);\r\n    }\r\n  }\r\n}\r\n\r\nexport { Gen };\r\n","/**\r\n * An implementation of Ken Perlin's noise algorithm in 2D.\r\n * \r\n * With thanks to Joe Iddon. https://github.com/joeiddon/perlin\r\n */\r\nclass Noise {\r\n  constructor() {\r\n    this.grad = {};\r\n    this.cache = {};\r\n  }\r\n\r\n  /**\r\n   * Get the noise value at the specified co-ordinates.\r\n   * \r\n   * @param {number} x - The noise x co-ordinate.\r\n   * @param {number} [y = 0] - The noise y co-ordinate.\r\n   * @returns {number} the noise value (float between -1 and 1).\r\n   */\r\n  get(x, y = 0) {\r\n    if (this.cache.hasOwnProperty([x, y])) return this.cache[[x, y]];\r\n    \r\n    let xf = Math.floor(x);\r\n    let yf = Math.floor(y);\r\n    \r\n    let tl = this.#gridDotProduct(x, y, xf, yf);\r\n    let tr = this.#gridDotProduct(x, y, xf + 1, yf);\r\n    let bl = this.#gridDotProduct(x, y, xf, yf + 1);\r\n    let br = this.#gridDotProduct(x, y, xf + 1, yf + 1);\r\n    \r\n    let xt = this.#fade(x - xf, tl, tr);\r\n    let xb = this.#fade(x - xf, bl, br);\r\n    let v = this.#fade(y - yf, xt, xb);\r\n    \r\n    this.cache[[x, y]] = v;\r\n    \r\n    return v;\r\n  }\r\n\r\n  #gridDotProduct(x, y, vx, vy){\r\n    let gVec, dVec = { x: x - vx, y: y - vy };\r\n\r\n    if (this.grad[[vx, vy]]){\r\n      gVec = this.grad[[vx, vy]];\r\n    } else {\r\n      let th = Math.random() * 2 * Math.PI;\r\n      gVec = { x: Math.cos(th), y: Math.sin(th) };\r\n      this.grad[[vx, vy]] = gVec;\r\n    }\r\n\r\n    return dVec.x * gVec.x + dVec.y * gVec.y;\r\n  }\r\n\r\n  #fade(x, a, b){\r\n    let s = 6 * x**5 - 15 * x**4 + 10 * x**3;\r\n    return a + s * (b - a);\r\n  }\r\n}\r\n\r\nexport { Noise };\r\n"],"names":["$85e5d838be2bb839$export$6db80416c61d51ca","constructor","element","namespace","this","document","createElementNS","isValid","nodeName","setAttribute","addEventListener","type","callback","node","appendChild","keyframes","options","animate","innerHTML","text","child","defsCheck","points","curveFactor","path","pathData","flat","i","length","x0","y0","x1","y1","x2","y2","set","d","stroke","fill","createFilter","id","isMainSVG","filter","x","y","width","height","filterUnits","color_interpolation_filters","createGradient","colours","rotation","gradient","create","stop_color","offset","createPattern","pattern","patternUnits","remove","get","attribute","getAttributeNS","getCentre","bbox","getBBox","moveTo","$097705c8ce77c34c$export$dde7b1cd7af1d184","n1","n2","Math","random","constrain","num","min","max","a","b","sqrt","pow","$61af366e9716361c$export$484d33a0500a4ce1","grad","cache","hasOwnProperty","xf","floor","yf","tl","gridDotProduct","tr","bl","br","xt","fade","xb","v","vx","vy","gVec","dVec","th","PI","cos","sin"],"version":3,"file":"svjs.min.js.map"}